SET session_replication_role = 'replica';

DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN (
        SELECT conname, conrelid::regclass AS tablename
        FROM pg_constraint
        WHERE contype = 'f' AND connamespace NOT IN ('pg_catalog'::regnamespace, 'information_schema'::regnamespace)
    )
    LOOP
        EXECUTE 'ALTER TABLE ' || quote_ident(r.tablename::text) || ' DROP CONSTRAINT IF EXISTS ' || quote_ident(r.conname);
    END LOOP;
END $$;

DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN (SELECT schemaname, viewname FROM pg_views WHERE schemaname NOT IN ('pg_catalog', 'information_schema'))
    LOOP
        EXECUTE 'DROP VIEW IF EXISTS ' || quote_ident(r.schemaname) || '.' || quote_ident(r.viewname) || ' CASCADE';
    END LOOP;
END $$;

DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname NOT IN ('pg_catalog', 'information_schema'))
    LOOP
        EXECUTE 'DROP TABLE IF EXISTS ' || quote_ident(r.tablename) || ' CASCADE';
    END LOOP;
END $$;

DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN (
        SELECT ns.nspname, p.proname, pg_get_function_identity_arguments(p.oid) AS args
        FROM pg_proc p
        JOIN pg_namespace ns ON ns.oid = p.pronamespace
        WHERE ns.nspname NOT IN ('pg_catalog', 'information_schema')
    )
    LOOP
        EXECUTE 'DROP FUNCTION IF EXISTS ' ||
                quote_ident(r.nspname) || '.' ||
                quote_ident(r.proname) ||
                '(' || r.args || ') CASCADE';
    END LOOP;
END $$;

DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN (
        SELECT t.typname
        FROM pg_type t
        JOIN pg_namespace n ON t.typnamespace = n.oid
        WHERE n.nspname = 'public'
        AND t.typtype = 'e'
    )
    LOOP
        EXECUTE 'DROP TYPE IF EXISTS ' || quote_ident(r.typname) || ' CASCADE';
    END LOOP;
END $$;

DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN (
        SELECT t.typname
        FROM pg_type t
        JOIN pg_namespace n ON t.typnamespace = n.oid
        WHERE n.nspname = 'public'
        AND t.typtype = 'c'
        AND NOT EXISTS (
            SELECT 1 FROM pg_class c
            WHERE c.relname = t.typname
            AND c.relkind = 'r'
        )
    )
    LOOP
        EXECUTE 'DROP TYPE IF EXISTS ' || quote_ident(r.typname) || ' CASCADE';
    END LOOP;
END $$;

DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN (SELECT sequence_name FROM information_schema.sequences WHERE sequence_schema = 'public')
    LOOP
        EXECUTE 'DROP SEQUENCE IF EXISTS ' || quote_ident(r.sequence_name) || ' CASCADE';
    END LOOP;
END $$;

SET session_replication_role = 'origin';

SET client_min_messages = warning;

CREATE TYPE task_status AS ENUM ('start', 'check', 'claim', 'done');

CREATE FUNCTION public.update_invites(user_tg_id bigint)
RETURNS TABLE(invites integer, invited_by bigint, tg_id bigint)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    UPDATE users AS u
    SET invites = u.invites + 1
    WHERE u.tg_id = user_tg_id
    RETURNING u.invites, u.invited_by, u.tg_id;
END;
$$;

CREATE FUNCTION public.enforce_not_nullable_on_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.invitee IS NULL THEN
        RAISE EXCEPTION 'invitee cannot be NULL';
    END IF;

    IF NEW.inviter IS NULL THEN
        RAISE EXCEPTION 'inviter cannot be NULL';
    END IF;

    RETURN NEW;
END;
$$;

CREATE TABLE users (
  id INT GENERATED BY DEFAULT AS IDENTITY,
  tg_id BIGINT NOT NULL,
  first_name VARCHAR(100) NOT NULL,
  username VARCHAR(32),
  address VARCHAR(55),
  language VARCHAR(5),
  farmed_amount INT DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  last_visit TIMESTAMPTZ NOT NULL DEFAULT now(),
  invited_by BIGINT,
  invites INT NOT NULL DEFAULT 0,
  farm_cigs INT NOT NULL DEFAULT 0,
  ref_cigs INT NOT NULL DEFAULT 0,
  end_time TIMESTAMPTZ,
  claim_friends TIMESTAMPTZ NOT NULL DEFAULT (now() + interval '24 hours'),
  activity_days INT NOT NULL DEFAULT 0,
  bonuses SMALLINT[] DEFAULT ARRAY[]::smallint[],
  selected_images SMALLINT[] DEFAULT ARRAY[]::smallint[],
  level INT NOT NULL DEFAULT 0,
  PRIMARY KEY (id),
  CONSTRAINT level_check CHECK (level >= 0 AND level <= 9),
  FOREIGN KEY (invited_by) REFERENCES users(tg_id) ON DELETE SET NULL ON UPDATE CASCADE,
  UNIQUE (tg_id),
  UNIQUE (first_name)
);

CREATE TABLE invites (
  id INT GENERATED BY DEFAULT AS IDENTITY,
  inviter BIGINT,
  invitee BIGINT,
  PRIMARY KEY (id),
  FOREIGN KEY (inviter) REFERENCES users(tg_id) ON DELETE SET NULL ON UPDATE CASCADE,
  FOREIGN KEY (invitee) REFERENCES users(tg_id) ON DELETE SET NULL ON UPDATE CASCADE
);

CREATE TABLE tasks (
  id INT GENERATED BY DEFAULT AS IDENTITY,
  type VARCHAR(20) NOT NULL CHECK (type IN ('invite', 'code', 'subscribe')),
  position INT NOT NULL,
  reward INT NOT NULL,
  icon VARCHAR(1024) NOT NULL,
  link VARCHAR(1024),
  active BOOLEAN NOT NULL DEFAULT true,
  language VARCHAR(5),
  delay INT,
  invites INT,
  codes TEXT[],
  PRIMARY KEY (id),
  CONSTRAINT check_invites CHECK (
    (type = 'invite' AND invites IS NOT NULL) OR
    (type != 'invite' AND invites IS NULL)
  ),
  CONSTRAINT check_codes CHECK (
    (type = 'code' AND codes IS NOT NULL) OR
    (type != 'code' AND codes IS NULL)
  ),
  CONSTRAINT check_delay CHECK (
    (type = 'subscribe' AND delay IS NOT NULL) OR
    (type != 'subscribe' AND delay IS NULL)
  )
);

CREATE TABLE user_tasks (
  user_id BIGINT NOT NULL,
  task_id INT NOT NULL,
  status task_status NOT NULL DEFAULT 'start',
  PRIMARY KEY (user_id, task_id),
  FOREIGN KEY (user_id) REFERENCES users(tg_id) ON DELETE CASCADE ON UPDATE CASCADE,
  FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE TABLE wallets (
  id INT GENERATED BY DEFAULT AS IDENTITY,
  user_id BIGINT NOT NULL,
  address VARCHAR(50) NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  last_connect TIMESTAMPTZ NOT NULL DEFAULT now(),
  FOREIGN KEY (user_id) REFERENCES users(tg_id) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE TABLE messages (
  id INT GENERATED BY DEFAULT AS IDENTITY,
  text TEXT NOT NULL,
  photo_url VARCHAR(1024),
  buttons JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO nodejs_user;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO nodejs_user;

ALTER FUNCTION public.enforce_not_nullable_on_insert() OWNER TO nodejs_user;
ALTER FUNCTION public.update_invites(user_tg_id bigint) OWNER TO nodejs_user;
CREATE TRIGGER check_invitee_inviter_not_null BEFORE INSERT ON invites FOR EACH ROW EXECUTE FUNCTION public.enforce_not_nullable_on_insert();
ALTER DEFAULT PRIVILEGES FOR ROLE nodejs_user IN SCHEMA public GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO nodejs_user;

-- ALTER TABLE invites ENABLE ROW LEVEL SECURITY;

-- CREATE UNIQUE INDEX uc_users_first_name ON users(first_name);
-- CREATE INDEX idx_users_tg_id ON users(tg_id);

-- ALTER TABLE users ADD CONSTRAINT fk_users_invited_by FOREIGN KEY (invited_by) REFERENCES users(tg_id);
-- ALTER TABLE invites ADD CONSTRAINT fk_invites_inviter FOREIGN KEY (inviter) REFERENCES users(tg_id);
-- ALTER TABLE invites ADD CONSTRAINT fk_invites_invitee FOREIGN KEY (invitee) REFERENCES users(tg_id);
-- ALTER TABLE user_tasks ADD CONSTRAINT fk_user_tasks_user_id FOREIGN KEY (user_id) REFERENCES users(tg_id);
-- ALTER TABLE user_tasks ADD CONSTRAINT fk_user_tasks_task_id FOREIGN KEY (task_id) REFERENCES tasks(id);
