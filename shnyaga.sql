SET session_replication_role = 'replica';

DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN (
        SELECT conname, conrelid::regclass AS tablename
        FROM pg_constraint
        WHERE contype = 'f' AND connamespace NOT IN ('pg_catalog'::regnamespace, 'information_schema'::regnamespace)
    )
    LOOP
        EXECUTE 'ALTER TABLE ' || quote_ident(r.tablename::text) || ' DROP CONSTRAINT IF EXISTS ' || quote_ident(r.conname);
    END LOOP;
END $$;

DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN (SELECT schemaname, viewname FROM pg_views WHERE schemaname NOT IN ('pg_catalog', 'information_schema'))
    LOOP
        EXECUTE 'DROP VIEW IF EXISTS ' || quote_ident(r.schemaname) || '.' || quote_ident(r.viewname) || ' CASCADE';
    END LOOP;
END $$;

DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname NOT IN ('pg_catalog', 'information_schema'))
    LOOP
        EXECUTE 'DROP TABLE IF EXISTS ' || quote_ident(r.tablename) || ' CASCADE';
    END LOOP;
END $$;

DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN (
        SELECT ns.nspname, p.proname, pg_get_function_identity_arguments(p.oid) AS args
        FROM pg_proc p
        JOIN pg_namespace ns ON ns.oid = p.pronamespace
        WHERE ns.nspname NOT IN ('pg_catalog', 'information_schema')
    )
    LOOP
        EXECUTE 'DROP FUNCTION IF EXISTS ' ||
                quote_ident(r.nspname) || '.' ||
                quote_ident(r.proname) ||
                '(' || r.args || ') CASCADE';
    END LOOP;
END $$;

DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN (
        SELECT t.typname
        FROM pg_type t
        JOIN pg_namespace n ON t.typnamespace = n.oid
        WHERE n.nspname = 'public'
        AND t.typtype = 'e'
    )
    LOOP
        EXECUTE 'DROP TYPE IF EXISTS ' || quote_ident(r.typname) || ' CASCADE';
    END LOOP;
END $$;

DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN (
        SELECT t.typname
        FROM pg_type t
        JOIN pg_namespace n ON t.typnamespace = n.oid
        WHERE n.nspname = 'public'
        AND t.typtype = 'c'
        AND NOT EXISTS (
            SELECT 1 FROM pg_class c
            WHERE c.relname = t.typname
            AND c.relkind = 'r'
        )
    )
    LOOP
        EXECUTE 'DROP TYPE IF EXISTS ' || quote_ident(r.typname) || ' CASCADE';
    END LOOP;
END $$;

DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN (SELECT sequence_name FROM information_schema.sequences WHERE sequence_schema = 'public')
    LOOP
        EXECUTE 'DROP SEQUENCE IF EXISTS ' || quote_ident(r.sequence_name) || ' CASCADE';
    END LOOP;
END $$;

SET session_replication_role = 'origin';

SET client_min_messages = warning;

CREATE FUNCTION public.enforce_not_nullable_on_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.invitee IS NULL THEN
        RAISE EXCEPTION 'invitee cannot be NULL';
    END IF;
    IF NEW.inviter IS NULL THEN
        RAISE EXCEPTION 'inviter cannot be NULL';
    END IF;
    RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION is_code_task(task_id INT) RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (SELECT 1 FROM tasks WHERE id = task_id AND type = 'code');
END;
$$
 LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION get_task_codes_length(p_task_id INT)
RETURNS INT AS $$
BEGIN
    RETURN (
        SELECT array_length(codes, 1)
        FROM tasks
        WHERE id = p_task_id
    );
END;
$$ LANGUAGE plpgsql IMMUTABLE;

CREATE OR REPLACE FUNCTION check_and_update_code(
    p_user_id BIGINT,
    p_task_id INT,
    p_code TEXT
) RETURNS TABLE (codes_amount INT, codes TEXT[]) AS $$
DECLARE
    code_exists BOOLEAN;
    current_codes TEXT[];
    task_codes_length INT;
BEGIN
    SELECT EXISTS (
        SELECT 1
        FROM tasks
        WHERE id = p_task_id AND p_code = ANY(tasks.codes)
    ) INTO code_exists;
    IF code_exists THEN
        SELECT ut.codes, ut.codes_amount INTO current_codes, task_codes_length
        FROM user_tasks ut
        WHERE ut.user_id = p_user_id AND ut.task_id = p_task_id;
        IF current_codes IS NULL THEN
            current_codes := ARRAY[]::TEXT[];
        END IF;
        IF p_code = ANY(current_codes) THEN
            RETURN;
        END IF;
        UPDATE user_tasks
        SET codes = array_append(current_codes, p_code)
        WHERE user_id = p_user_id AND task_id = p_task_id
        RETURNING user_tasks.codes_amount, user_tasks.codes INTO task_codes_length, current_codes;
        RETURN QUERY SELECT task_codes_length, current_codes;
    ELSE
        RETURN;
    END IF;
END;
$$
 LANGUAGE plpgsql;

CREATE TABLE users (
  id INT GENERATED BY DEFAULT AS IDENTITY,
  tg_id BIGINT NOT NULL,
  first_name VARCHAR(100) NOT NULL,
  username VARCHAR(32),
  language VARCHAR(5),
  farmed_amount INT DEFAULT 0,
  farmed_time INT DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  last_visit TIMESTAMPTZ NOT NULL DEFAULT now(),
  invited_by BIGINT,
  invites INT NOT NULL DEFAULT 0,
  farm_cigs INT NOT NULL DEFAULT 0,
  ref_cigs INT NOT NULL DEFAULT 0,
  end_time TIMESTAMPTZ,
  claim_friends TIMESTAMPTZ NOT NULL DEFAULT (now() + interval '24 hours'),
  activity_days INT NOT NULL DEFAULT 0,
  bonuses SMALLINT[] DEFAULT ARRAY[]::smallint[],
  selected_images SMALLINT[] DEFAULT ARRAY[-1,-1,-1,-1,-1,-1,-1,-1,-1],
  level INT NOT NULL DEFAULT 0,
  PRIMARY KEY (id),
  CONSTRAINT level_check CHECK (level >= 0 AND level <= 9),
  FOREIGN KEY (invited_by) REFERENCES users(tg_id) ON DELETE SET NULL ON UPDATE CASCADE,
  UNIQUE (tg_id),
  UNIQUE (first_name)
);

CREATE TABLE invites (
  id INT GENERATED BY DEFAULT AS IDENTITY,
  inviter BIGINT,
  invitee BIGINT,
  PRIMARY KEY (id),
  FOREIGN KEY (inviter) REFERENCES users(tg_id) ON DELETE SET NULL ON UPDATE CASCADE,
  FOREIGN KEY (invitee) REFERENCES users(tg_id) ON DELETE SET NULL ON UPDATE CASCADE
);

CREATE TABLE tasks (
  id INT GENERATED BY DEFAULT AS IDENTITY,
  type VARCHAR(20) NOT NULL CHECK (type IN ('invite', 'code', 'subscribe')),
  position INT,
  reward INT NOT NULL,
  icon VARCHAR(1024) NOT NULL,
  link VARCHAR(1024),
  active BOOLEAN NOT NULL DEFAULT true,
  language VARCHAR(5),
  delay INT,
  invites INT,
  codes TEXT[],
  PRIMARY KEY (id),
  CONSTRAINT check_invites CHECK (
    (type = 'invite' AND invites IS NOT NULL) OR
    (type != 'invite' AND invites IS NULL)
  ),
  CONSTRAINT check_codes CHECK (
    (type = 'code' AND codes IS NOT NULL) OR
    (type != 'code' AND codes IS NULL)
  ),
  CONSTRAINT check_delay CHECK (
    (type = 'subscribe' AND delay IS NOT NULL) OR
    (type != 'subscribe' AND delay IS NULL)
  )
);

CREATE TABLE user_tasks (
  user_id BIGINT NOT NULL,
  task_id INT NOT NULL,
  status VARCHAR(10) NOT NULL DEFAULT 'start' CHECK (status IN ('start', 'check', 'claim', 'done')),
  codes TEXT[],
  codes_amount INT GENERATED ALWAYS AS (
    get_task_codes_length(task_id)
  ) STORED,
  PRIMARY KEY (user_id, task_id),
  FOREIGN KEY (user_id) REFERENCES users(tg_id) ON DELETE CASCADE ON UPDATE CASCADE,
  FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT check_codes_for_code_tasks CHECK (
    is_code_task(task_id) = (codes IS NOT NULL)
  )
);

CREATE TABLE wallets (
  id INT GENERATED BY DEFAULT AS IDENTITY,
  user_id BIGINT NOT NULL,
  address VARCHAR(80) NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  last_connect TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (address),
  PRIMARY KEY (id),
  FOREIGN KEY (user_id) REFERENCES users(tg_id) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE TABLE messages (
  id INT GENERATED BY DEFAULT AS IDENTITY,
  text TEXT NOT NULL,
  photo_url VARCHAR(1024),
  buttons JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (id)
);

GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO nodejs_user;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO nodejs_user;

ALTER FUNCTION public.enforce_not_nullable_on_insert() OWNER TO nodejs_user;
CREATE TRIGGER check_invitee_inviter_not_null BEFORE INSERT ON invites FOR EACH ROW EXECUTE FUNCTION public.enforce_not_nullable_on_insert();
ALTER DEFAULT PRIVILEGES FOR ROLE nodejs_user IN SCHEMA public GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO nodejs_user;

-- ALTER TABLE invites ENABLE ROW LEVEL SECURITY;

-- CREATE UNIQUE INDEX uc_users_first_name ON users(first_name);
-- CREATE INDEX idx_users_tg_id ON users(tg_id);

-- ALTER TABLE users ADD CONSTRAINT fk_users_invited_by FOREIGN KEY (invited_by) REFERENCES users(tg_id);
-- ALTER TABLE invites ADD CONSTRAINT fk_invites_inviter FOREIGN KEY (inviter) REFERENCES users(tg_id);
-- ALTER TABLE invites ADD CONSTRAINT fk_invites_invitee FOREIGN KEY (invitee) REFERENCES users(tg_id);
-- ALTER TABLE user_tasks ADD CONSTRAINT fk_user_tasks_user_id FOREIGN KEY (user_id) REFERENCES users(tg_id);
-- ALTER TABLE user_tasks ADD CONSTRAINT fk_user_tasks_task_id FOREIGN KEY (task_id) REFERENCES tasks(id);
